
#+PROPERTY: header-args :tangle "~/.emacs.d/init.el" :comments link
Sources:
- [[https://github.com/seagle0128/.emacs.d][Seagle0128]]

* User and System Definitions
** Directories
(file-name-as-directory dir) will return directory path dir with a trailing slash, adding one if necessary, and not otherwise.
 #+BEGIN_SRC emacs-lisp
   ;; Set the emacs directory
   (setq user-emacs-directory (file-name-directory user-init-file))
   ;; Set the home directory
   (defvar user-home-directory (expand-file-name "~/"))
 #+END_SRC

* Package Management
** Package Sources
Set the sources for any packages to be installed.
Note that these sources are locally installed mirrors from the [[https://github.com/d12frosted/elpa-mirror][Elpa Mirror]].
Further bump up the memory before garbage collection starts, to speed up loading the config.
#+BEGIN_SRC emacs-lisp
  ;; Increase the garbage collector memory to 500MB
  (setq gc-cons-threshold (* 500 1024 1024))
  (add-hook 'after-init-hook (lambda () (setq gc-cons-threshold (* 5 1024 1024))))

  (require 'package)
  (setq package-archives
        `(("melpa"        . ,(concat user-home-directory ".elpa-mirror/melpa/"))
          ("org"          . ,(concat user-home-directory ".elpa-mirror/org/"))
          ("melba-stable" . ,(concat user-home-directory ".elpa-mirror/melpa-stable/"))
          ("gnu"          . ,(concat user-home-directory ".elpa-mirror/gnu/"))))
#+END_SRC

** Use-package install
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (unless (bound-and-true-p package--initialized) ; To avoid warnings in 27
      (setq package-enable-at-startup nil)          ; To prevent initializing twice
      (package-initialize)))

  ;; Setup `use-package'
  (eval-when-compile
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)
      (package-install 'diminish)
      (package-install 'bind-key)))

  ;; Should set before loading `use-package'
  (eval-and-compile
    ;;Don't use (setq use-package-always-ensure t). It prevents customising build in packages.
    (setq use-package-always-defer t)
    (setq use-package-expand-minimally t)
    (setq use-package-enable-imenu-support t))

  (eval-when-compile
    (setq use-package-verbose t)
    (setq use-package-minimum-reported-time 0.01)
    (require 'use-package)
    (require 'diminish)
    (require 'bind-key))
#+END_SRC

** Use-package configuration
 Now that se-package is installed, extend its' functionality
#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :ensure t
    :custom
    (system-packages-noconfirm t))

  (use-package use-package-ensure-system-package
    :ensure t)

  ;; diminish keyword
  (use-package diminish
    :ensure t)

  ;; bind keyword
  (use-package bind-key
    :ensure t)
#+END_SRC
* Global Defaults
** Common
These have been defined in C code, so use -emacs- pseudo-package to set them
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (put 'narrow-to-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
    :custom
    (scroll-step 1)
    (inhibit-startup-screen t "Don't show splash screen")
    (use-dialog-box nil "Disable dialog boxes")
    (x-gtk-use-system-tooltips nil)
    (enable-recursive-minibuffers t "Allow minibuffer commands in the minibuffer")
    (indent-tabs-mode nil "Spaces!")
    (debug-on-quit nil))
#+END_SRC
** Other built in settings
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind([remap list-buffers] . ibuffer))
#+END_SRC
** Highlighting
#+BEGIN_SRC emacs-lisp
  (use-package paren
    :config
    (show-paren-mode t))

  (use-package hl-line
    :hook
    (prog-mode . hl-line-mode))

  (use-package highlight-numbers
    :ensure t
    :hook
    (prog-mode . highlight-numbers-mode))

  (use-package highlight-escape-sequences
    :ensure t
    :config (hes-mode))

  (use-package hl-todo
    :ensure t
    :hook
    (prog-mode . hl-todo-mode))

  (use-package rainbow-delimiters
    :ensure t
    :hook
    (prog-mode . rainbow-delimiters-mode))

  (use-package rainbow-mode
    :ensure t
    :diminish
    :hook prog-mode)
#+END_SRC
** TODO Files
Saving file
Conflicts with magit. Confused about backup folder
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package files
    :hook
    (before-save . delete-trailing-whitespace)
    :custom
    (require-final-newline t)
    ;; backup settings
    (make-backup-files t)
    (backup-by-copying t)
    (backup-directory-alist
     '(("." . ,(expand-file-name
                 (concat user-emacs-directory ".backups")))))
    (delete-old-versions t)
    (delete-by-moving-to-trash t)
    (kept-new-version 5)
    (kept-old-versions 2)
    (auto-save-default t)
    (auto-save-interval 200)
    (version-control t))
#+END_SRC

Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :custom
    (recentf-auto-cleanup 30)
    :config
    (run-with-idle-timer 30 t 'recentf-save-list))
#+END_SRC

Customize to a sperate file
#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :custom
    (custom-file (expand-file-name ".custom.el" user-emacs-directory) "Store customizations in seperate file"))

  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC
* Global Tools
** Elmacro
Super handy tool to look at how macro's expand.
For example the use-package macro expands in how packages are loaded
- Expand with C-c e m
- Collapse with u or backspace
#+BEGIN_SRC emacs-lisp
  (use-package macrostep
    :ensure t
    :bind
    (("C-c e m" . macrostep-expand)))
#+END_SRC
** Expand Region
Expand the region of selection.
- Start using C-+ to expand ro C-- to contract
- C-r ... have many other selection options
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind
    (("C-=" . er/expand-region)
     ("C--" . er/contract-region)
     :map mode-specific-map
     :prefix-map region-prefix-map
     :prefix "r"
     ("(" . er/mark-inside-pairs)
     (")" . er/mark-outside-pairs)
     ("'" . er/mark-inside-quotes)
     ([34] . er/mark-outside-quotes) ; it's just a quotation mark
     ("o" . er/mark-org-parent)
     ("u" . er/mark-url)
     ("b" . er/mark-org-code-block)
     ("." . er/mark-method-call)
     (">" . er/mark-next-accessor)
     ("w" . er/mark-word)
     ("d" . er/mark-defun)
     ("e" . er/mark-email)
     ("," . er/mark-symbol)
     ("<" . er/mark-symbol-with-prefix)
     (";" . er/mark-comment)
     ("s" . er/mark-sentence)
     ("S" . er/mark-text-sentence)
     ("p" . er/mark-paragraph)
     ("P" . er/mark-text-paragraph)))
#+END_SRC

Edit a selection seperately in a buffer
#+BEGIN_SRC emacs-lisp
  (use-package edit-indirect
    :ensure t
    :after expand-region
    :bind
    (:map region-prefix-map
          ("r" . edit-indirect-region)))
#+END_SRC
* User Interface
** Localization
#+BEGIN_SRC emacs-lisp
  (use-package mule
    :config
    (prefer-coding-system 'utf-8)
    (set-language-environment "UTF-8")
    (set-terminal-coding-system 'utf-8))
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp
  (use-package faces
    :defer 0.1
    :custom
    (face-font-family-alternatives '(("Source Code Pro")))
    :config
    (set-face-attribute 'default
                        nil
                        :family (caar face-font-family-alternatives)
                        :weight 'regular
                        :width 'semi-condensed
                        :height 120))
#+END_SRC

** GUI
Disable gui elements we likely ever use
#+BEGIN_SRC emacs-lisp
  (use-package tool-bar
    :config
    (tool-bar-mode -1))

  (use-package menu-bar
    :config
    (menu-bar-mode -1))

  (use-package scroll-bar
    :config
    (scroll-bar-mode -1))

  (use-package tooltip
    :defer t
    :custom
    (tooltip-mode -1))

#+END_SRC

** Some fancy gadgets for graphics
 #+BEGIN_SRC emacs-lisp
   (use-package time
     :defer t
     :custom
     (display-time-default-load-average nil)
     (display-time-24hr-format t)
     :config
     (display-time-mode t))

   (use-package fancy-battery
     :ensure t
     :hook
     (after-init . fancy-battery-mode))

   ;;(use-package font-lock+
   ;;  :quelpa
   ;;  (font-lock+ :repo "emacsmirror/font-lock-plus" :fetcher github))

   (use-package all-the-icons
     :ensure t
     :defer t
     :config
     (setq all-the-icons-mode-icon-alist
           `(,@all-the-icons-mode-icon-alist
             (package-menu-mode all-the-icons-octicon "package" :v-adjust 0.0)
             (jabber-chat-mode all-the-icons-material "chat" :v-adjust 0.0)
             (jabber-roster-mode all-the-icons-material "contacts" :v-adjust 0.0)
             (telega-chat-mode all-the-icons-fileicon "telegram" :v-adjust 0.0
                               :face all-the-icons-blue-alt)
             (telega-root-mode all-the-icons-material "contacts" :v-adjust 0.0))))

   (use-package all-the-icons-dired
     :ensure t
     :hook
     (dired-mode . all-the-icons-dired-mode))

   (use-package all-the-icons-ivy
     :ensure t
     :after ivy
     :custom
     (all-the-icons-ivy-buffer-commands '() "Don't use for buffers.")
     :config
     (all-the-icons-ivy-setup))
 #+END_SRC

** Modeline
The nicest out there at the moment is doom-modeline.
 #+BEGIN_SRC emacs-lisp
   (use-package doom-modeline
     :ensure t
     :hook
     (after-init . doom-modeline-mode)
     :custom
     (doom-modeline-major-mode-icon t)
     (doom-modeline-buffer-file-name-style 'buffer-name)
     (doom-modeline-icon t))
 #+END_SRC
** Theme
Like the build in theme of wombat. Good vibrance of colours and not too dark.
 #+BEGIN_SRC emacs-lisp
   (load-theme 'wombat)
 #+END_SRC

** Dashboard
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :demand t
    :diminish dashboard-mode
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-banner-logo-title "Welcome to EMacs Erwin")
    (dashboard-startup-banner (expand-file-name "emacs.png" user-emacs-directory))
    (dashboard-items '((recents  . 5)
                       (agenda . 10)
                       (bookmarks . 5)
                       (projects . 5)
                       (registers . 5))))
#+END_SRC

* Help
Some tools that help explaining what is available, etc
** Which-key
Perfect tool to tell what key sequences are defined after starting our key sequence.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :defer 3
    :diminish
    :commands which-key-mode
    :config
    (which-key-mode))
#+END_SRC
** Company mode
Auto completion
#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer 3
    :ensure t
    :diminish
    :commands (company-mode company-indent-or-complete-common)
    :init
    (dolist (hook '(emacs-lisp-mode-hook))
      (add-hook hook
                #'(lambda ()
                    (local-set-key (kbd "<tab>")
                                   #'company-indent-or-complete-common))))
    :config
    (global-company-mode 1)
    (use-package company-quickhelp
      :ensure t
      :defer t
      :custom
      (company-quickhelp-delay 3)
      :config
      (company-quickhelp-mode 1)))
#+END_SRC
** Helpful
A much improved help system on the familiar key bindings
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-h C" . helpful-command)
     ("C-h F" . helpful-function)))
#+END_SRC
* Search, Narrow and Minibuffers
Best combination of search and narrowing software is Ivy|Counsel and Swiper.
It can do everything Helm can do, is however much smaller in footprint.
** Ivy
Ivy provides an interface to list, search, filter and perform actions on a collection of "things". These "things" can range from strings to buffers, Ivy doesn't really care. It just provides a way for the user to interact with this collection.
Ivy is a generic completion mechanism for Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :demand t
    :diminish ivy-mode
    :custom
    ;; Displays the current and total number in the collection in the prompt
    (ivy-count-format "%d%d " "Show anzu-like counter")
    (ivy-use-selectable-prompt t "Make the prompt line selectable")
    (ivy-dynamic-exhibit-delay-ms 200)
    (ivy-height 10)
    ;;Add recent files and bookmarks to the ivy-switch-buffer
    (ivy-use-virtual-buffers t)
    (ivy-wrap t)
    :custom-face
    (ivy-current-match ((t (:inherit 'hl-line))))
    :bind
    (("C-x b" . ivy-switch-buffer)
     ("C-x B" . ivy-switch-buffer-other-window)
     ("C-r"   . ivy-resume))
    :bind
    (:map ivy-minibuffer-map
          ("<tab>" . ivy-alt-done)
          ;;("SPC"   . ivy-alt-done-or-space)
          ("C-d"   . ivy-done-or-delete-char)
          ("C-i"   . ivy-partial-or-done)
          ("C-r"   . ivy-previous-line-or-history)
          ("M-r"   . ivy-reverse-i-search))
    :bind
    (:map ivy-switch-buffer-map
          ("C-k"   . ivy-switch-buffer-kill))
    :config
    (ivy-mode 1)
    (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))
#+END_SRC

** Counsel
Counsel functions to be found under C-c c {counsel} a -> counsel-appropose
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :bind
  (([remap menu-bar-open] . counsel-tmm)
   ([remap insert-char] . counsel-unicode-char)
   ([remap isearch-forward] . counsel-grep-or-swiper)
   :map mode-specific-map
   :prefix-map counsel-prefix-map
   :prefix "c"
   ("a" . counsel-apropos)
   ("b" . counsel-bookmark)
   ("B" . counsel-bookmarked-directory)
   ("c w" . counsel-colors-web)
   ("c e" . counsel-colors-emacs)
   ("d" . counsel-dired-jump)
   ("f" . counsel-file-jump)
   ("F" . counsel-faces)
   ("g" . counsel-org-goto)
   ("h" . counsel-command-history)
   ("H" . counsel-minibuffer-history)
   ("i" . counsel-imenu)
   ("j" . counsel-find-symbol)
   ("l" . counsel-locate)
   ("L" . counsel-find-library)
   ("m" . counsel-mark-ring)
   ("o" . counsel-outline)
   ("O" . counsel-find-file-extern)
   ("p" . counsel-package)
   ("r" . counsel-recentf)
   ("s g" . counsel-grep)
   ("s r" . counsel-rg)
   ("s s" . counsel-ag)
   ("t" . counsel-org-tag)
   ("v" . counsel-set-variable)
   ("w" . counsel-wmctrl)
   :map help-map
   ("F" . counsel-describe-face))
  :init
  (counsel-mode))
#+END_SRC
** Swiper
Find text in your buffer, but cleverly.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :after ivy
    :bind
    ("C-s"  . swiper)
    :bind
    (:map swiper-map
          ("M-y" . yank)
          ("M-%" . swiper-query-replace)
          ("C-." . swiper-avy)
          ("M-c" . swiper-mc))
    :bind
    (:map isearch-mode-map
         ("C-o" . swiper-from-isearch)))
#+END_SRC

* Version control
One of the main advantages of emacs is everything is text based.
This call for version control using git. Magit is the tool to take advantage of both.
** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :hook (magit-mode  . hl-line-mode)
    :bind
    (("C-x g"  . magit-status)
     ("C-x G"  . magit-status-with-prefix))
    :bind
    (:map mode-specific-map
          :prefix-map magit-prefix-map
          :prefix "m"
          (("a" . magit-stage-file) ; the closest analog to git add
           ("b" . magit-blame)
           ("B" . magit-branch)
           ("c" . magit-checkout)
           ("C" . magit-commit)
           ("d" . magit-diff)
           ("D" . magit-discard)
           ("f" . magit-fetch)
           ("g" . vc-git-grep)
           ("G" . magit-gitignore)
           ("i" . magit-init)
           ("l" . magit-log)
           ("m" . magit)
           ("M" . magit-merge)
           ("n" . magit-notes-edit)
           ("p" . magit-pull-branch)
           ("P" . magit-push-current)
           ("r" . magit-reset)
           ("R" . magit-rebase)
           ("s" . magit-status)
           ("S" . magit-stash)
           ("t" . magit-tag)
           ("T" . magit-tag-delete)
           ("u" . magit-unstage)
           ("U" . magit-update-index))))
#+END_SRC
** IBuffer-vc 
Provide the Git status of open buffers in a list
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc
    :ensure t
    :config
    (define-ibuffer-column icon
      (:name "Icon" :inline t)
      (all-the-icons-ivy--icon-for-mode major-mode))
    :custom
    (ibuffer-formats
     '((mark modified read-only vc-status-mini " "
             (name 18 18 :left :elide)
             " "
             (size 9 -1 :right)
             " "
             (mode 16 16 :left :elide)
             " "
             filename-and-process)) "include vc status info")
    :hook
    (ibuffer . (lambda ()
                 (ibuffer-vc-set-filter-groups-by-vc-root)
                 (unless (eq ibuffer-sorting-mode 'alphabetic)
                   (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC
** Git modes
#+BEGIN_SRC emacs-lisp
  (use-package gitconfig-mode
    :ensure t
    :defer t)

  (use-package gitignore-mode
    :ensure t
    :defer t)
#+END_SRC
** Diff-hl
diff-hl-mode highlights uncommitted changes on the left side of the window, allows you to jump between and revert them selectively.
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :ensure t
    :hook
    ((magit-post-refresh-hook . diff-hl-post-refresh)
     (prog-mode . diff-hl-margin-mode)
     (org-mode . diff-hl-margin-mode)
     (dired-mode . diff-hl-dired-mode)))
#+END_SRC
* Programming
** General
*** Paredit
Ensure that parenthesis are always paired
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :diminish paredit-mode
    :commands (paredit-mode)
    :hook ((lisp-mode emacs-lisp-mode) . paredit-mode))
#+END_SRC
*** Smart Commenting
#+BEGIN_SRC emacs-lisp
  (use-package smart-comment
    :ensure t
    :bind
    ("M-;" . smart-comment))
#+END_SRC
*** Projectile
Provides easy project management and navigation. The concept of a project is pretty basic - just a folder containing special file. Currently git, mercurial, darcs and bazaar repos are considered projects by default. So are lein, maven, sbt, scons, rebar and bundler projects. If you want to mark a folder manually as a project just create an empty .projectile file in it.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :bind
    (:map mode-specific-map ("p" . projectile-command-map))
    :custom
    (projectile-project-root-files-functions
     '(projectile-root-local
       projectile-root-top-down
       projectile-root-bottom-up
       projectile-root-top-down-recurring))
    (projectile-completion-system 'ivy))

  (use-package counsel-projectile
    :ensure t
    :after counsel prokectile
    :config
    (counsel-projectile-mode))
#+END_SRC
*** Flycheck
On-the-fly syntax checking
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :diminish flycheck-mode
    :hook
    (prog-mode . flycheck-mode))

  (use-package avy-flycheck
    :defer t
    :config
    (avy-flycheck-setup))
#+END_SRC
** Emacs Lisp
#+BEGIN_SRC emacs-lisp

  ;; Check if all parenthesis are in place after save
  ;; Places the pointer on the faulty line. Invaluable.
  (use-package lisp
    :hook
    (after-save . check-parens))

  ;; Highlights defined Emacs Lisp symbols in source code.
  ;; Currently it recognizes Lisp function, built-in function, macro, face and variable names.
  (use-package highlight-defined
    :ensure t
    :custom
    (highlight-defined-face-use-itself t)
    :hook
    (emacs-lisp-mode . highlight-defined-mode))

  ;; Highlight of Lisp quotes and quoted symbols
  (use-package highlight-quoted
    :ensure t
    :hook
    (emacs-lisp-mode . highlight-quoted-mode))

  ;; Evaluation Result OverlayS for Emacs Lisp.
  (use-package eros
    :ensure t
    :hook
    (emacs-lisp-mode . eros-mode))

  ;;Discovering elisp functions based on examples
  (use-package suggest
    :ensure t
    :defer t)

  ;; Pretty symbols
  (use-package ipretty
    :ensure t
    :config
    (ipretty-mode 1))

  ;; provides a flycheck checker for the metadata in Emacs Lisp files which are intended to be packages.
  (use-package flycheck-package
    :ensure t
    :defer t
    :after flycheck
    (flycheck-package-setup))
#+END_SRC
* Applications
** COMMENT Organisation
The main reason for using emacs - lets get organised - with everything
Sample of nicer bullets [[http://nadeausoftware.com/articles/2007/11/latency_friendly_customized_bullets_using_unicode_characters][inspiration]]
*** Org Mode
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure nil            ;org-plus-config
    :custom
    ;; Set the Org main directory where org files are located
    (org-directory "~/Org")
    ;; Set the list of files that form the agenda
    (org-agenda-files (directory-files org-directory t directory-files-no-dot-files-regexp))
    ;; 
    ;;(org-default-notes-file (concat org-directory "/notes.org"))
    (org-src-tab-acts-natively t "Tabs work natively")
    (org-startup-indented t "Headers and content are indented")
    (org-pretty-entities t "Pretty symbols rather than non UTF-8 sysmbols")
    (org-hide-emphasis-markers t "Hide the emphesis markers")
    (org-log-done 'note "Record time annd note when task changes to done")
    (org-todo-keywords '((sequence "TODO(t)" "ACTIVE(a)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))
    (org-todo-keywordfaces '(("WAITING" . warning)))
    :hook
    (org-mode . (lambda () (visual-line-mode)))
    (org-indent-mode . (lambda () (diminish 'org-indent-mode)))
    :bind (("C-c o a" . org-agenda)       ;Open org agenda
           ("C-c o b" . org-switchb)      ;Switch org buffer
           ("C-c o c" . org-capture)      ;Org capture
           ("C-c o l" . org-store-link)   ;Org store link
           )
    :config

    ;; More advanced bullet points
    (use-package org-bullets
      :ensure t
      :custom
      ;; define some nicer bullets
      (org-bullets-bullet-list '("\x25A3" "\x2B1A" "\x25D9" "\x25D8"))
      :if (char-displayable-p ?◉)
      :hook (org-mode . org-bullets-mode))

    ;; More advanced priority symbols
    (use-package org-fancy-priorities
      :ensure t
      :diminish
      :defines org-fancy-priority-list
      :hook (org-mode . org-fancy-priorities-mode)
      :config (unless (char-displayable-p ?❗)
                  (setq org-fancy-priorities-list '("HIGH" "MID" "LOW" "OPTIONAL")))))
#+END_SRC
* The End
#+BEGIN_SRC emacs-lisp
(setq dashboard-banner-logo-title (concat "Welcome to Emacs: " user-full-name ". Startup time: " (emacs-init-time)))
#+END_SRC

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
