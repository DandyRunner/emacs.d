#+PROPERTY: header-args :tangle "~/.emacs.d/init.el" :comments link
* Package System
** Package sources
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'package)
  (setq package-archives
	`(("melpa" . ,(concat "/home/ejansen/" ".elpa-mirror/melpa/"))
	  ("org"   . ,(concat "/home/ejansen/" ".elpa-mirror/org/"))
	  ("gnu"   . ,(concat "/home/ejansen/" ".elpa-mirror/gnu/")))))
#+END_SRC

** Use-package install
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (unless (bound-and-true-p package--initialized) ; To avoid warnings in 27
      (setq package-enable-at-startup nil)          ; To prevent initializing twice
      (package-initialize)))

  ;; Setup `use-package'
  (eval-when-compile
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)))

  ;; Should set before loading `use-package'
  (eval-and-compile
    ;;Don't use (setq use-package-always-ensure t). It prevents customising build in packages.
    (setq use-package-always-defer t)
    (setq use-package-expand-minimally t)
    (setq use-package-enable-imenu-support t))

  (eval-when-compile
    (setq use-package-verbose t)
    (setq use-package-minimum-reported-time 0.01)
    (require 'use-package))
#+END_SRC

** Use-package configuration
Now that se-package is installed, extend its' functionality
#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :ensure t
    :custom
    (system-packages-noconfirm t))

  (use-package use-package-ensure-system-package
    :ensure t)

  ;; diminish keyword
  (use-package diminish
    :ensure t)

  ;; bind keyword
  (use-package bind-key
    :ensure t)
#+END_SRC
* Global Defaults
** Common
These have been defined in C code, so use -emacs- pseudo-package to set them
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (put 'narrow-to-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
    :custom
    (scroll-step 1)
    (inhibit-startup-screen t "Don't show splash screen")
    (use-dialog-box nil "Disable dialog boxes")
    (x-gtk-use-system-tooltips nil)
    (enable-recursive-minibuffers t "Allow minibuffer commands in the minibuffer")
    (indent-tabs-mode nil "Spaces!")
    (debug-on-quit nil))
#+END_SRC
** Other built in settings
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind([remap list-buffers] . ibuffer))
#+END_SRC
** Highlighting
#+BEGIN_SRC emacs-lisp
  (use-package paren
    :config
    (show-paren-mode t))

  (use-package hl-line
    :hook
    (prog-mode . hl-line-mode))

  (use-package highlight-numbers
    :ensure t
    :hook
    (prog-mode . highlight-numbers-mode))

  (use-package highlight-escape-sequences
    :ensure t
    :config (hes-mode))

  (use-package hl-todo
    :ensure t
    :hook
    (prog-mode . hl-todo-mode))

  (use-package rainbow-delimiters
    :ensure t
    :hook
    (prog-mode . rainbow-delimiters-mode))

  (use-package rainbow-mode
    :ensure t
    :diminish
    :hook prog-mode)
#+END_SRC
** TODO Files
Saving file
Conflicts with magit. Confused about backup folder
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package files
    :hook
    (before-save . delete-trailing-whitespace)
    :custom
    (require-final-newline t)
    ;; backup settings
    (make-backup-files t)
    (backup-by-copying t)
    (backup-directory-alist
     '(("." . ,(expand-file-name
                 (concat user-emacs-directory ".backups")))))
    (delete-old-versions t)
    (delete-by-moving-to-trash t)
    (kept-new-version 5)
    (kept-old-versions 2)
    (auto-save-default t)
    (auto-save-interval 200)
    (version-control t))
#+END_SRC

Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :custom
    (recentf-auto-cleanup 30)
    :config
    (run-with-idle-timer 30 t 'recentf-save-list))
#+END_SRC

Customize to a sperate file
#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :custom
    ;;(custom-file null-device "Don't store customizations"))
    (custom-file (expand-file-name ".custom.el" user-emacs-directory) "Store customizations in seperate file"))

  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

* User Interface
** Localization
#+BEGIN_SRC emacs-lisp
  (use-package mule
    :config
    (prefer-coding-system 'utf-8)
    (set-language-environment "UTF-8")
    (set-terminal-coding-system 'utf-8))
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp
  (use-package faces
    :defer 0.1
    :custom
    (face-font-family-alternatives '(("Source Code Pro")))
    :config
    (set-face-attribute 'default
                        nil
                        :family (caar face-font-family-alternatives)
                        :weight 'regular
                        :width 'semi-condensed
                        :height 120))
#+END_SRC

** GUI
Disable gui elements we likely ever use
#+BEGIN_SRC emacs-lisp
  (use-package tool-bar
    :config
    (tool-bar-mode -1))

  (use-package menu-bar
    :config
    (menu-bar-mode -1))

  (use-package scroll-bar
    :config
    (scroll-bar-mode -1))

  (use-package tooltip
    :defer t
    :custom
    (tooltip-mode -1))

#+END_SRC
** Theme
Like the build in theme of wombat. Good vibrance of colours and not too dark.
 #+BEGIN_SRC emacs-lisp
   (use-package darktooth-theme
     :ensure t
     :demand t
     :config
     (load-theme 'darktooth))
   ;;(load-theme 'wombat)
 #+END_SRC

** Some fancy gadgets for graphics
 #+BEGIN_SRC emacs-lisp
   (use-package time
     :defer t
     :custom
     (display-time-default-load-average nil)
     (display-time-24hr-format t)
     :config
     (display-time-mode t))

   (use-package fancy-battery
     :ensure t
     :hook
     (after-init . fancy-battery-mode))

   ;;(use-package font-lock+
   ;;  :quelpa
   ;;  (font-lock+ :repo "emacsmirror/font-lock-plus" :fetcher github))

   (use-package all-the-icons
     :ensure t
     :defer t
     :config
     (setq all-the-icons-mode-icon-alist
           `(,@all-the-icons-mode-icon-alist
             (package-menu-mode all-the-icons-octicon "package" :v-adjust 0.0)
             (jabber-chat-mode all-the-icons-material "chat" :v-adjust 0.0)
             (jabber-roster-mode all-the-icons-material "contacts" :v-adjust 0.0)
             (telega-chat-mode all-the-icons-fileicon "telegram" :v-adjust 0.0
                               :face all-the-icons-blue-alt)
             (telega-root-mode all-the-icons-material "contacts" :v-adjust 0.0))))

   (use-package all-the-icons-dired
     :ensure t
     :hook
     (dired-mode . all-the-icons-dired-mode))

   (use-package all-the-icons-ivy
     :ensure t
     :after ivy
     :custom
     (all-the-icons-ivy-buffer-commands '() "Don't use for buffers.")
     :config
     (all-the-icons-ivy-setup))
 #+END_SRC

** Modeline
The nicest out there at the moment is doom-modeline.
 #+BEGIN_SRC emacs-lisp
   (use-package doom-modeline
     :ensure t
     :hook
     (after-init . doom-modeline-mode)
     :custom
     (doom-modeline-major-mode-icon t)
     (doom-modeline-buffer-file-name-style 'buffer-name)
     (doom-modeline-icon t))
 #+END_SRC

** Dashboard
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    :custom
    (initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    (dashboard-items '((recents  . 5)
                       (bookmarks . 5)
                       (projects . 5)
                       (agenda . 5)
                       (registers . 5))))
#+END_SRC

* Help
Some tools that help explaining what is available, etc
** Which-key
Perfect tool to tell what key sequences are defined after starting our key sequence.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :defer 3
    :diminish
    :commands which-key-mode
    :config
    (which-key-mode))
#+END_SRC
** Company mode
Auto completion
#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer 3
    :ensure t
    :diminish
    :commands (company-mode company-indent-or-complete-common)
    :init
    (dolist (hook '(emacs-lisp-mode-hook))
      (add-hook hook
                #'(lambda ()
                    (local-set-key (kbd "<tab>")
                                   #'company-indent-or-complete-common))))
    :config
    (global-company-mode 1))
#+END_SRC

* Search, Narrow and Minibuffers
Best combination of search and narrowing software is Ivy|Counsel and Swiper.
It can do everything Helm can do, is however much smaller in footprint.
** Ivy
Ivy provides an interface to list, search, filter and perform actions on a collection of "things". These "things" can range from strings to buffers, Ivy doesn't really care. It just provides a way for the user to interact with this collection.
Ivy is a generic completion mechanism for Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :demand t
    :diminish ivy-mode
    :custom
    ;; Displays the current and total number in the collection in the prompt
    (ivy-count-format "%d%d " "Show anzu-like counter")
    (ivy-use-selectable-prompt t "Make the prompt line selectable")
    (ivy-dynamic-exhibit-delay-ms 200)
    (ivy-height 10)
    ;;Add recent files and bookmarks to the ivy-switch-buffer
    (ivy-use-virtual-buffers t)
    (ivy-wrap t)
    :custom-face
    (ivy-current-match ((t (:inherit 'hl-line))))
    :bind
    (("C-x b" . ivy-switch-buffer)
     ("C-x B" . ivy-switch-buffer-other-window)
     ("C-r"   . ivy-resume))
    :bind
    (:map ivy-minibuffer-map
          ("<tab>" . ivy-alt-done)
          ;;("SPC"   . ivy-alt-done-or-space)
          ("C-d"   . ivy-done-or-delete-char)
          ("C-i"   . ivy-partial-or-done)
          ("C-r"   . ivy-previous-line-or-history)
          ("M-r"   . ivy-reverse-i-search))
    :bind
    (:map ivy-switch-buffer-map
          ("C-k"   . ivy-switch-buffer-kill))
    :config
    (ivy-mode 1)
    (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))
#+END_SRC

** Counsel
Counsel functions to be found under C-c c {counsel} a -> counsel-appropose
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :bind
  (([remap menu-bar-open] . counsel-tmm)
   ([remap insert-char] . counsel-unicode-char)
   ([remap isearch-forward] . counsel-grep-or-swiper)
   :map mode-specific-map
   :prefix-map counsel-prefix-map
   :prefix "c"
   ("a" . counsel-apropos)
   ("b" . counsel-bookmark)
   ("B" . counsel-bookmarked-directory)
   ("c w" . counsel-colors-web)
   ("c e" . counsel-colors-emacs)
   ("d" . counsel-dired-jump)
   ("f" . counsel-file-jump)
   ("F" . counsel-faces)
   ("g" . counsel-org-goto)
   ("h" . counsel-command-history)
   ("H" . counsel-minibuffer-history)
   ("i" . counsel-imenu)
   ("j" . counsel-find-symbol)
   ("l" . counsel-locate)
   ("L" . counsel-find-library)
   ("m" . counsel-mark-ring)
   ("o" . counsel-outline)
   ("O" . counsel-find-file-extern)
   ("p" . counsel-package)
   ("r" . counsel-recentf)
   ("s g" . counsel-grep)
   ("s r" . counsel-rg)
   ("s s" . counsel-ag)
   ("t" . counsel-org-tag)
   ("v" . counsel-set-variable)
   ("w" . counsel-wmctrl)
   :map help-map
   ("F" . counsel-describe-face))
  :init
  (counsel-mode))
#+END_SRC
** Swiper
Find text in your buffer, but cleverly.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :after ivy
    :bind
    ("C-s"  . swiper)
    :bind
    (:map swiper-map
          ("M-y" . yank)
          ("M-%" . swiper-query-replace)
          ("C-." . swiper-avy)
          ("M-c" . swiper-mc))
    :bind
    (:map isearch-mode-map
         ("C-o" . swiper-from-isearch)))
#+END_SRC

* Version control
One of the main advantages of emacs is everything is text based.
This call for version control using git. Magit is the tool to take advantage of both.
** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :hook (magit-mode  . hl-line-mode)
    :bind
    (("C-x g"  . magit-status)
     ("C-x G"  . magit-status-with-prefix)))
#+END_SRC
* The End
;;; # eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)(byte-compile-file "~/.emacs.d/init.el")) nil t)
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
